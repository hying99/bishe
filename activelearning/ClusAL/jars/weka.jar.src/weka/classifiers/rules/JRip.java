package weka.classifiers.rules;

import java.io.Serializable;
import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;
import weka.classifiers.Classifier;
import weka.classifiers.Evaluation;
import weka.core.AdditionalMeasureProducer;
import weka.core.Attribute;
import weka.core.Copyable;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.UnsupportedAttributeTypeException;
import weka.core.UnsupportedClassTypeException;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;
import weka.filters.Filter;
import weka.filters.supervised.attribute.ClassOrder;

public class JRip extends Classifier implements OptionHandler, AdditionalMeasureProducer, WeightedInstancesHandler {
  private static double MAX_DL_SURPLUS = 64.0D;
  
  private Attribute m_Class;
  
  private FastVector m_Ruleset;
  
  private FastVector m_Distributions;
  
  private int m_Optimizations = 2;
  
  private Random m_Random = null;
  
  private double m_Total = 0.0D;
  
  private long m_Seed = 1L;
  
  private int m_Folds = 3;
  
  private double m_MinNo = 2.0D;
  
  private boolean m_Debug = false;
  
  private boolean m_CheckErr = true;
  
  private boolean m_UsePruning = true;
  
  private Filter m_Filter = null;
  
  private FastVector m_RulesetStats;
  
  public String globalInfo() {
    return "This class implements a propositional rule learner, Repeated Incremental Pruning to Produce Error Reduction (RIPPER), which was proposed by William W. Cohen as an optimized version of IREP. \n\nThe algorithm is briefly described as follows: \n\nInitialize RS = {}, and for each class from the less prevalent one to the more frequent one, DO: \n\n1. Building stage:\nRepeat 1.1 and 1.2 until the descrition length (DL) of the ruleset and examples is 64 bits greater than the smallest DL met so far, or there are no positive examples, or the error rate >= 50%. \n\n1.1. Grow phase:\nGrow one rule by greedily adding antecedents (or conditions) to the rule until the rule is perfect (i.e. 100% accurate).  The procedure tries every possible value of each attribute and selects the condition with highest information gain: p(log(p/t)-log(P/T)).\n\n1.2. Prune phase:\nIncrementally prune each rule and allow the pruning of any final sequences of the antecedents;The pruning metric is (p-n)/(p+n) -- but it's actually 2p/(p+n) -1, so in this implementation we simply use p/(p+n) (actually (p+1)/(p+n+2), thus if p+n is 0, it's 0.5).\n\n2. Optimization stage:\n after generating the initial ruleset {Ri}, generate and prune two variants of each rule Ri from randomized data using procedure 1.1 and 1.2. But one variant is generated from an empty rule while the other is generated by greedily adding antecedents to the original rule. Moreover, the pruning metric used here is (TP+TN)/(P+N).Then the smallest possible DL for each variant and the original rule is computed.  The variant with the minimal DL is selected as the final representative of Ri in the ruleset.After all the rules in {Ri} have been examined and if there are still residual positives, more rules are generated based on the residual positives using Building Stage again. \n3. Delete the rules from the ruleset that would increase the DL of the whole ruleset if it were in it. and add resultant ruleset to RS. \nENDDO\n\nNote that there seem to be 2 bugs in the original ripper program that would affect the ruleset size and accuracy slightly.  This implementation avoids these bugs and thus is a little bit different from Cohen's original implementation. Even after fixing the bugs, since the order of classes with the same frequency is not defined in ripper, there still seems to be some trivial difference between this implementation and the original ripper, especially for audiology data in UCI repository, where there are lots of classes of few instances.\n\nDetails please see \"Fast Effective Rule Induction\", William W. Cohen, 'Machine Learning: Proceedings of the Twelfth International Conference'(ML95). \n\nPS.  We have compared this implementation with the original ripper implementation in aspects of accuracy, ruleset size and running time on both artificial data \"ab+bcd+defg\" and UCI datasets.  In all these aspects it seems to be quite comparable to the original ripper implementation.  However, we didn't consider memory consumption optimization in this implementation.\n\n";
  }
  
  public Enumeration listOptions() {
    Vector vector = new Vector(3);
    vector.addElement(new Option("\tSet number of folds for REP\n\tOne fold is used as pruning set.\n\t(default 3)", "F", 1, "-F <number of folds>"));
    vector.addElement(new Option("\tSet the minimal weights of instances\n\twithin a split.\n\t(default 2.0)", "N", 1, "-N <min. weights>"));
    vector.addElement(new Option("\tSet the number of runs of\n\toptimizations. (Default: 2)", "O", 1, "-O <number of runs>"));
    vector.addElement(new Option("\tSet whether turn on the\n\tdebug mode (Default: false)", "D", 0, "-D"));
    vector.addElement(new Option("\tThe seed of randomization\n\t(Default: 1)", "S", 1, "-S <seed>"));
    vector.addElement(new Option("Whether NOT check the error rate>=0.5\n\tin stopping criteria \t(default: check)", "E", 0, "-E"));
    vector.addElement(new Option("Whether NOT use pruning\n\t(default: use pruning)", "P", 0, "-P"));
    return vector.elements();
  }
  
  public void setOptions(String[] paramArrayOfString) throws Exception {
    String str1 = Utils.getOption('F', paramArrayOfString);
    if (str1.length() != 0) {
      this.m_Folds = Integer.parseInt(str1);
    } else {
      this.m_Folds = 3;
    } 
    String str2 = Utils.getOption('N', paramArrayOfString);
    if (str2.length() != 0) {
      this.m_MinNo = Double.parseDouble(str2);
    } else {
      this.m_MinNo = 2.0D;
    } 
    String str3 = Utils.getOption('S', paramArrayOfString);
    if (str3.length() != 0) {
      this.m_Seed = Long.parseLong(str3);
    } else {
      this.m_Seed = 1L;
    } 
    String str4 = Utils.getOption('O', paramArrayOfString);
    if (str4.length() != 0) {
      this.m_Optimizations = Integer.parseInt(str4);
    } else {
      this.m_Optimizations = 2;
    } 
    this.m_Debug = Utils.getFlag('D', paramArrayOfString);
    this.m_CheckErr = !Utils.getFlag('E', paramArrayOfString);
    this.m_UsePruning = !Utils.getFlag('P', paramArrayOfString);
  }
  
  public String[] getOptions() {
    String[] arrayOfString = new String[11];
    byte b = 0;
    arrayOfString[b++] = "-F";
    arrayOfString[b++] = "" + this.m_Folds;
    arrayOfString[b++] = "-N";
    arrayOfString[b++] = "" + this.m_MinNo;
    arrayOfString[b++] = "-O";
    arrayOfString[b++] = "" + this.m_Optimizations;
    arrayOfString[b++] = "-S";
    arrayOfString[b++] = "" + this.m_Seed;
    if (this.m_Debug)
      arrayOfString[b++] = "-D"; 
    if (!this.m_CheckErr)
      arrayOfString[b++] = "-E"; 
    if (!this.m_UsePruning)
      arrayOfString[b++] = "-P"; 
    while (b < arrayOfString.length)
      arrayOfString[b++] = ""; 
    return arrayOfString;
  }
  
  public Enumeration enumerateMeasures() {
    Vector vector = new Vector(1);
    vector.addElement("measureNumRules");
    return vector.elements();
  }
  
  public double getMeasure(String paramString) {
    if (paramString.compareToIgnoreCase("measureNumRules") == 0)
      return this.m_Ruleset.size(); 
    throw new IllegalArgumentException(paramString + " not supported (RIPPER)");
  }
  
  public String foldsTipText() {
    return "Determines the amount of data used for pruning. One fold is used for pruning, the rest for growing the rules.";
  }
  
  public void setFolds(int paramInt) {
    this.m_Folds = paramInt;
  }
  
  public int getFolds() {
    return this.m_Folds;
  }
  
  public String minNoTipText() {
    return "The minimum total weight of the instances in a rule.";
  }
  
  public void setMinNo(double paramDouble) {
    this.m_MinNo = paramDouble;
  }
  
  public double getMinNo() {
    return this.m_MinNo;
  }
  
  public String seedTipText() {
    return "The seed used for randomizing the data.";
  }
  
  public void setSeed(long paramLong) {
    this.m_Seed = paramLong;
  }
  
  public long getSeed() {
    return this.m_Seed;
  }
  
  public String optimizationsTipText() {
    return "The number of optimization runs.";
  }
  
  public void setOptimizations(int paramInt) {
    this.m_Optimizations = paramInt;
  }
  
  public int getOptimizations() {
    return this.m_Optimizations;
  }
  
  public String debugTipText() {
    return "Whether debug information is output to the console.";
  }
  
  public void setDebug(boolean paramBoolean) {
    this.m_Debug = paramBoolean;
  }
  
  public boolean getDebug() {
    return this.m_Debug;
  }
  
  public String checkErrorRateTipText() {
    return "Whether check for error rate >= 1/2 is included in stopping criterion.";
  }
  
  public void setCheckErrorRate(boolean paramBoolean) {
    this.m_CheckErr = paramBoolean;
  }
  
  public boolean getCheckErrorRate() {
    return this.m_CheckErr;
  }
  
  public String usePruningTipText() {
    return "Whether pruning is performed.";
  }
  
  public void setUsePruning(boolean paramBoolean) {
    this.m_UsePruning = paramBoolean;
  }
  
  public boolean getUsePruning() {
    return this.m_UsePruning;
  }
  
  public FastVector getRuleset() {
    return this.m_Ruleset;
  }
  
  public RuleStats getRuleStats(int paramInt) {
    return (RuleStats)this.m_RulesetStats.elementAt(paramInt);
  }
  
  public void buildClassifier(Instances paramInstances) throws Exception {
    if (paramInstances.numInstances() == 0)
      throw new Exception(" No instances with a class value!"); 
    if (paramInstances.checkForStringAttributes())
      throw new UnsupportedAttributeTypeException(" Cannot handle string attributes!"); 
    if (!paramInstances.classAttribute().isNominal())
      throw new UnsupportedClassTypeException(" Only nominal class, please."); 
    this.m_Random = paramInstances.getRandomNumberGenerator(this.m_Seed);
    this.m_Total = RuleStats.numAllConditions(paramInstances);
    if (this.m_Debug)
      System.err.println("Number of all possible conditions = " + this.m_Total); 
    Instances instances = null;
    this.m_Filter = (Filter)new ClassOrder();
    ((ClassOrder)this.m_Filter).setSeed(this.m_Random.nextInt());
    ((ClassOrder)this.m_Filter).setClassOrder(0);
    this.m_Filter.setInputFormat(paramInstances);
    instances = Filter.useFilter(paramInstances, this.m_Filter);
    if (instances == null)
      throw new Exception(" Unable to randomize the class orders."); 
    instances.deleteWithMissingClass();
    if (instances.numInstances() == 0)
      throw new Exception(" No instances with a class value!"); 
    if (instances.numInstances() < this.m_Folds)
      throw new Exception(" Not enough data for REP."); 
    this.m_Class = instances.classAttribute();
    this.m_Ruleset = new FastVector();
    this.m_RulesetStats = new FastVector();
    this.m_Distributions = new FastVector();
    double[] arrayOfDouble = ((ClassOrder)this.m_Filter).getClassCounts();
    if (this.m_Debug) {
      System.err.println("Sorted classes:");
      for (byte b = 0; b < this.m_Class.numValues(); b++)
        System.err.println(b + ": " + this.m_Class.value(b) + " has " + arrayOfDouble[b] + " instances."); 
    } 
    for (byte b1 = 0; b1 < instances.numClasses() - 1; b1++) {
      double d = b1;
      if (this.m_Debug) {
        int i = (int)d;
        System.err.println("\n\nClass " + this.m_Class.value(i) + "(" + i + "): " + arrayOfDouble[b1] + "instances\n" + "=====================================\n");
      } 
      if (!Utils.eq(arrayOfDouble[b1], 0.0D)) {
        double d1 = 0.0D;
        for (byte b3 = b1; b3 < arrayOfDouble.length; b3++)
          d1 += arrayOfDouble[b3]; 
        double d2 = arrayOfDouble[b1] / d1;
        double d3 = 0.0D;
        double d4 = 0.0D;
        for (byte b4 = 0; b4 < instances.numInstances(); b4++) {
          Instance instance = instances.instance(b4);
          d4 += instance.weight();
          if ((int)instance.classValue() == b1)
            d3 += instance.weight(); 
        } 
        if (d3 > 0.0D) {
          double d5 = RuleStats.dataDL(d2, 0.0D, d4, 0.0D, d3);
          if (Double.isNaN(d5) || Double.isInfinite(d5))
            throw new Exception("Should never happen: defDL NaN or infinite!"); 
          if (this.m_Debug)
            System.err.println("The default DL = " + d5); 
          instances = rulesetForOneClass(d2, instances, d, d5);
        } 
      } 
    } 
    RipperRule ripperRule = new RipperRule(this);
    ripperRule.setConsequent((instances.numClasses() - 1));
    this.m_Ruleset.addElement(ripperRule);
    RuleStats ruleStats = new RuleStats();
    ruleStats.setData(instances);
    ruleStats.setNumAllConds(this.m_Total);
    ruleStats.addAndUpdate(ripperRule);
    this.m_RulesetStats.addElement(ruleStats);
    for (byte b2 = 0; b2 < this.m_RulesetStats.size(); b2++) {
      RuleStats ruleStats1 = (RuleStats)this.m_RulesetStats.elementAt(b2);
      for (byte b = 0; b < ruleStats1.getRulesetSize(); b++) {
        double[] arrayOfDouble1 = ruleStats1.getDistributions(b);
        Utils.normalize(arrayOfDouble1);
        if (arrayOfDouble1 != null)
          this.m_Distributions.addElement(((ClassOrder)this.m_Filter).distributionsByOriginalIndex(arrayOfDouble1)); 
      } 
    } 
  }
  
  public double[] distributionForInstance(Instance paramInstance) {
    try {
      for (byte b = 0; b < this.m_Ruleset.size(); b++) {
        RipperRule ripperRule = (RipperRule)this.m_Ruleset.elementAt(b);
        if (ripperRule.covers(paramInstance))
          return (double[])this.m_Distributions.elementAt(b); 
      } 
    } catch (Exception exception) {
      System.err.println(exception.getMessage());
      exception.printStackTrace();
    } 
    System.err.println("Should never happen!");
    return new double[paramInstance.classAttribute().numValues()];
  }
  
  protected Instances rulesetForOneClass(double paramDouble1, Instances paramInstances, double paramDouble2, double paramDouble3) throws Exception {
    Instances instances = paramInstances;
    boolean bool1 = false;
    FastVector fastVector = new FastVector();
    double d1 = paramDouble3;
    double d2 = paramDouble3;
    RuleStats ruleStats1 = null;
    boolean bool2 = true;
    boolean bool3 = bool2;
    if (this.m_Debug)
      System.err.println("\n*** Building stage ***"); 
    while (!bool1 && bool3) {
      RipperRule ripperRule;
      if (this.m_UsePruning) {
        instances = RuleStats.stratify(instances, this.m_Folds, this.m_Random);
        Instances[] arrayOfInstances = RuleStats.partition(instances, this.m_Folds);
        Instances instances1 = arrayOfInstances[0];
        Instances instances2 = arrayOfInstances[1];
        ripperRule = new RipperRule(this);
        ripperRule.setConsequent(paramDouble2);
        if (this.m_Debug)
          System.err.println("\nGrowing a rule ..."); 
        ripperRule.grow(instances1);
        if (this.m_Debug)
          System.err.println("One rule found before pruning:" + ripperRule.toString(this.m_Class)); 
        if (this.m_Debug)
          System.err.println("\nPruning the rule ..."); 
        ripperRule.prune(instances2, false);
        if (this.m_Debug)
          System.err.println("One rule found after pruning:" + ripperRule.toString(this.m_Class)); 
      } else {
        ripperRule = new RipperRule(this);
        ripperRule.setConsequent(paramDouble2);
        if (this.m_Debug)
          System.err.println("\nNo pruning: growing a rule ..."); 
        ripperRule.grow(instances);
        if (this.m_Debug)
          System.err.println("No pruning: one rule found:\n" + ripperRule.toString(this.m_Class)); 
      } 
      if (ruleStats1 == null) {
        ruleStats1 = new RuleStats();
        ruleStats1.setNumAllConds(this.m_Total);
        ruleStats1.setData(instances);
      } 
      ruleStats1.addAndUpdate(ripperRule);
      int i = ruleStats1.getRuleset().size() - 1;
      d1 += ruleStats1.relativeDL(i, paramDouble1, this.m_CheckErr);
      if (Double.isNaN(d1) || Double.isInfinite(d1))
        throw new Exception("Should never happen: dl in building stage NaN or infinite!"); 
      if (this.m_Debug)
        System.err.println("Before optimization(" + i + "): the dl = " + d1 + " | best: " + d2); 
      if (d1 < d2)
        d2 = d1; 
      double[] arrayOfDouble = ruleStats1.getSimpleStats(i);
      if (this.m_Debug)
        System.err.println("The rule covers: " + arrayOfDouble[0] + " | pos = " + arrayOfDouble[2] + " | neg = " + arrayOfDouble[4] + "\nThe rule doesn't cover: " + arrayOfDouble[1] + " | pos = " + arrayOfDouble[5]); 
      bool1 = checkStop(arrayOfDouble, d2, d1);
      if (!bool1) {
        fastVector.addElement(ripperRule);
        instances = ruleStats1.getFiltered(i)[1];
        bool3 = Utils.gr(arrayOfDouble[5], 0.0D);
        if (this.m_Debug)
          System.err.println("One rule added: has positive? " + bool3); 
        continue;
      } 
      if (this.m_Debug)
        System.err.println("Quit rule"); 
      ruleStats1.removeLast();
    } 
    RuleStats ruleStats2 = null;
    if (this.m_UsePruning)
      for (byte b = 0; b < this.m_Optimizations; b++) {
        if (this.m_Debug)
          System.err.println("\n*** Optimization: run #" + b + " ***"); 
        instances = paramInstances;
        ruleStats2 = new RuleStats();
        ruleStats2.setData(instances);
        ruleStats2.setNumAllConds(this.m_Total);
        byte b1 = 0;
        bool1 = false;
        boolean bool = false;
        bool3 = bool2;
        d1 = d2 = paramDouble3;
        while (!bool1 && bool3) {
          RipperRule ripperRule;
          bool = (b1 >= fastVector.size()) ? true : false;
          instances = RuleStats.stratify(instances, this.m_Folds, this.m_Random);
          Instances[] arrayOfInstances = RuleStats.partition(instances, this.m_Folds);
          Instances instances1 = arrayOfInstances[0];
          Instances instances2 = arrayOfInstances[1];
          if (this.m_Debug)
            System.err.println("\nRule #" + b1 + "| isResidual?" + bool + "| data size: " + instances.sumOfWeights()); 
          if (bool) {
            RipperRule ripperRule1 = new RipperRule(this);
            ripperRule1.setConsequent(paramDouble2);
            if (this.m_Debug)
              System.err.println("\nGrowing and pruning a new rule ..."); 
            ripperRule1.grow(instances1);
            ripperRule1.prune(instances2, false);
            ripperRule = ripperRule1;
            if (this.m_Debug)
              System.err.println("\nNew rule found: " + ripperRule1.toString(this.m_Class)); 
          } else {
            RipperRule ripperRule1 = (RipperRule)fastVector.elementAt(b1);
            boolean bool4 = false;
            for (byte b2 = 0; b2 < instances.numInstances(); b2++) {
              if (ripperRule1.covers(instances.instance(b2))) {
                bool4 = true;
                break;
              } 
            } 
            if (!bool4) {
              ruleStats2.addAndUpdate(ripperRule1);
              b1++;
              continue;
            } 
            if (this.m_Debug)
              System.err.println("\nGrowing and pruning Replace ..."); 
            RipperRule ripperRule2 = new RipperRule(this);
            ripperRule2.setConsequent(paramDouble2);
            ripperRule2.grow(instances1);
            instances2 = RuleStats.rmCoveredBySuccessives(instances2, fastVector, b1);
            ripperRule2.prune(instances2, true);
            if (this.m_Debug)
              System.err.println("\nGrowing and pruning Revision ..."); 
            RipperRule ripperRule3 = (RipperRule)ripperRule1.copy();
            Instances instances3 = new Instances(instances1, 0);
            for (byte b3 = 0; b3 < instances1.numInstances(); b3++) {
              Instance instance = instances1.instance(b3);
              if (ripperRule3.covers(instance))
                instances3.add(instance); 
            } 
            ripperRule3.grow(instances3);
            ripperRule3.prune(instances2, true);
            double[][] arrayOfDouble2 = new double[b1][6];
            for (byte b4 = 0; b4 < b1; b4++)
              arrayOfDouble2[b4] = ruleStats2.getSimpleStats(b4); 
            FastVector fastVector1 = (FastVector)fastVector.copyElements();
            fastVector1.setElementAt(ripperRule2, b1);
            RuleStats ruleStats3 = new RuleStats(paramInstances, fastVector1);
            ruleStats3.setNumAllConds(this.m_Total);
            ruleStats3.countData(b1, instances, arrayOfDouble2);
            double[] arrayOfDouble1 = ruleStats3.getSimpleStats(b1);
            if (this.m_Debug)
              System.err.println("Replace rule covers: " + arrayOfDouble1[0] + " | pos = " + arrayOfDouble1[2] + " | neg = " + arrayOfDouble1[4] + "\nThe rule doesn't cover: " + arrayOfDouble1[1] + " | pos = " + arrayOfDouble1[5]); 
            double d3 = ruleStats3.relativeDL(b1, paramDouble1, this.m_CheckErr);
            if (this.m_Debug)
              System.err.println("\nReplace: " + ripperRule2.toString(this.m_Class) + " |dl = " + d3); 
            if (Double.isNaN(d3) || Double.isInfinite(d3))
              throw new Exception("Should never happen: repDLin optmz. stage NaN or infinite!"); 
            fastVector1.setElementAt(ripperRule3, b1);
            RuleStats ruleStats4 = new RuleStats(paramInstances, fastVector1);
            ruleStats4.setNumAllConds(this.m_Total);
            ruleStats4.countData(b1, instances, arrayOfDouble2);
            double d4 = ruleStats4.relativeDL(b1, paramDouble1, this.m_CheckErr);
            if (this.m_Debug)
              System.err.println("Revision: " + ripperRule3.toString(this.m_Class) + " |dl = " + d4); 
            if (Double.isNaN(d4) || Double.isInfinite(d4))
              throw new Exception("Should never happen: revDLin optmz. stage NaN or infinite!"); 
            ruleStats1 = new RuleStats(paramInstances, fastVector);
            ruleStats1.setNumAllConds(this.m_Total);
            ruleStats1.countData(b1, instances, arrayOfDouble2);
            double d5 = ruleStats1.relativeDL(b1, paramDouble1, this.m_CheckErr);
            if (Double.isNaN(d5) || Double.isInfinite(d5))
              throw new Exception("Should never happen: oldDLin optmz. stage NaN or infinite!"); 
            if (this.m_Debug)
              System.err.println("Old rule: " + ripperRule1.toString(this.m_Class) + " |dl = " + d5); 
            if (this.m_Debug)
              System.err.println("\nrepDL: " + d3 + "\nrevDL: " + d4 + "\noldDL: " + d5); 
            if (d5 <= d4 && d5 <= d3) {
              ripperRule = ripperRule1;
            } else if (d4 <= d3) {
              ripperRule = ripperRule3;
            } else {
              ripperRule = ripperRule2;
            } 
          } 
          ruleStats2.addAndUpdate(ripperRule);
          double[] arrayOfDouble = ruleStats2.getSimpleStats(b1);
          if (bool) {
            d1 += ruleStats2.relativeDL(b1, paramDouble1, this.m_CheckErr);
            if (this.m_Debug)
              System.err.println("After optimization: the dl=" + d1 + " | best: " + d2); 
            if (d1 < d2)
              d2 = d1; 
            bool1 = checkStop(arrayOfDouble, d2, d1);
            if (!bool1) {
              fastVector.addElement(ripperRule);
            } else {
              ruleStats2.removeLast();
              b1--;
            } 
          } else {
            fastVector.setElementAt(ripperRule, b1);
          } 
          if (this.m_Debug) {
            System.err.println("The rule covers: " + arrayOfDouble[0] + " | pos = " + arrayOfDouble[2] + " | neg = " + arrayOfDouble[4] + "\nThe rule doesn't cover: " + arrayOfDouble[1] + " | pos = " + arrayOfDouble[5]);
            System.err.println("\nRuleset so far: ");
            for (byte b2 = 0; b2 < fastVector.size(); b2++)
              System.err.println(b2 + ": " + ((RipperRule)fastVector.elementAt(b2)).toString(this.m_Class)); 
            System.err.println();
          } 
          if (ruleStats2.getRulesetSize() > 0)
            instances = ruleStats2.getFiltered(b1)[1]; 
          bool3 = Utils.gr(arrayOfDouble[5], 0.0D);
          b1++;
        } 
        if (fastVector.size() > b1 + 1)
          for (int i = b1 + 1; i < fastVector.size(); i++)
            ruleStats2.addAndUpdate((Rule)fastVector.elementAt(i));  
        if (this.m_Debug)
          System.err.println("\nDeleting rules to decrease DL of the whole ruleset ..."); 
        ruleStats2.reduceDL(paramDouble1, this.m_CheckErr);
        if (this.m_Debug) {
          int i = fastVector.size() - ruleStats2.getRulesetSize();
          System.err.println(i + " rules are deleted" + " after DL reduction procedure");
        } 
        fastVector = ruleStats2.getRuleset();
        ruleStats1 = ruleStats2;
      }  
    if (this.m_Debug) {
      System.err.println("\nFinal ruleset: ");
      for (byte b = 0; b < fastVector.size(); b++)
        System.err.println(b + ": " + ((RipperRule)fastVector.elementAt(b)).toString(this.m_Class)); 
      System.err.println();
    } 
    this.m_Ruleset.appendElements(fastVector);
    this.m_RulesetStats.addElement(ruleStats1);
    return (fastVector.size() > 0) ? ruleStats1.getFiltered(fastVector.size() - 1)[1] : paramInstances;
  }
  
  private boolean checkStop(double[] paramArrayOfdouble, double paramDouble1, double paramDouble2) {
    if (paramDouble2 > paramDouble1 + MAX_DL_SURPLUS) {
      if (this.m_Debug)
        System.err.println("DL too large: " + paramDouble2 + " | " + paramDouble1); 
      return true;
    } 
    if (!Utils.gr(paramArrayOfdouble[2], 0.0D)) {
      if (this.m_Debug)
        System.err.println("Too few positives."); 
      return true;
    } 
    if (paramArrayOfdouble[4] / paramArrayOfdouble[0] >= 0.5D) {
      if (this.m_CheckErr) {
        if (this.m_Debug)
          System.err.println("Error too large: " + paramArrayOfdouble[4] + "/" + paramArrayOfdouble[0]); 
        return true;
      } 
      return false;
    } 
    if (this.m_Debug)
      System.err.println("Continue."); 
    return false;
  }
  
  public String toString() {
    if (this.m_Ruleset == null)
      return "JRIP: No model built yet."; 
    StringBuffer stringBuffer = new StringBuffer("JRIP rules:\n===========\n\n");
    byte b;
    for (b = 0; b < this.m_RulesetStats.size(); b++) {
      RuleStats ruleStats = (RuleStats)this.m_RulesetStats.elementAt(b);
      FastVector fastVector = ruleStats.getRuleset();
      for (byte b1 = 0; b1 < fastVector.size(); b1++) {
        double[] arrayOfDouble = ruleStats.getSimpleStats(b1);
        stringBuffer.append(((RipperRule)fastVector.elementAt(b1)).toString(this.m_Class) + " (" + arrayOfDouble[0] + "/" + arrayOfDouble[4] + ")\n");
      } 
    } 
    if (this.m_Debug) {
      System.err.println("Inside m_Ruleset");
      for (b = 0; b < this.m_Ruleset.size(); b++)
        System.err.println(((RipperRule)this.m_Ruleset.elementAt(b)).toString(this.m_Class)); 
    } 
    stringBuffer.append("\nNumber of Rules : " + this.m_Ruleset.size() + "\n");
    return stringBuffer.toString();
  }
  
  public static void main(String[] paramArrayOfString) {
    try {
      System.out.println(Evaluation.evaluateModel(new JRip(), paramArrayOfString));
    } catch (Exception exception) {
      exception.printStackTrace();
      System.err.println(exception.getMessage());
    } 
  }
  
  protected class RipperRule extends Rule {
    private double m_Consequent;
    
    protected FastVector m_Antds;
    
    private final JRip this$0;
    
    public void setConsequent(double param1Double) {
      this.m_Consequent = param1Double;
    }
    
    public double getConsequent() {
      return this.m_Consequent;
    }
    
    public RipperRule(JRip this$0) {
      this.this$0 = this$0;
      this.m_Consequent = -1.0D;
      this.m_Antds = null;
      this.m_Antds = new FastVector();
    }
    
    public Object copy() {
      RipperRule ripperRule = new RipperRule(this.this$0);
      ripperRule.setConsequent(getConsequent());
      ripperRule.m_Antds = (FastVector)this.m_Antds.copyElements();
      return ripperRule;
    }
    
    public boolean covers(Instance param1Instance) {
      boolean bool = true;
      for (byte b = 0; b < this.m_Antds.size(); b++) {
        JRip.Antd antd = (JRip.Antd)this.m_Antds.elementAt(b);
        if (!antd.covers(param1Instance)) {
          bool = false;
          break;
        } 
      } 
      return bool;
    }
    
    public boolean hasAntds() {
      return (this.m_Antds == null) ? false : ((this.m_Antds.size() > 0));
    }
    
    public double size() {
      return this.m_Antds.size();
    }
    
    private double computeDefAccu(Instances param1Instances) {
      double d = 0.0D;
      for (byte b = 0; b < param1Instances.numInstances(); b++) {
        Instance instance = param1Instances.instance(b);
        if ((int)instance.classValue() == (int)this.m_Consequent)
          d += instance.weight(); 
      } 
      return d;
    }
    
    public void grow(Instances param1Instances) throws Exception {
      if (this.m_Consequent == -1.0D)
        throw new Exception(" Consequent not set yet."); 
      Instances instances = param1Instances;
      double d1 = instances.sumOfWeights();
      if (!Utils.gr(d1, 0.0D))
        return; 
      double d2 = computeDefAccu(instances);
      double d3 = (d2 + 1.0D) / (d1 + 1.0D);
      boolean[] arrayOfBoolean = new boolean[instances.numAttributes()];
      int i;
      for (i = 0; i < arrayOfBoolean.length; i++)
        arrayOfBoolean[i] = false; 
      i = arrayOfBoolean.length;
      for (byte b = 0; b < this.m_Antds.size(); b++) {
        JRip.Antd antd = (JRip.Antd)this.m_Antds.elementAt(b);
        if (!antd.getAttr().isNumeric()) {
          arrayOfBoolean[antd.getAttr().index()] = true;
          i--;
        } 
      } 
      while (Utils.gr(instances.numInstances(), 0.0D) && i > 0 && Utils.sm(d3, 1.0D)) {
        double d = 0.0D;
        JRip.NominalAntd nominalAntd = null;
        Instances instances1 = null;
        Enumeration enumeration = instances.enumerateAttributes();
        while (enumeration.hasMoreElements()) {
          JRip.NominalAntd nominalAntd1;
          Attribute attribute = enumeration.nextElement();
          if (this.this$0.m_Debug)
            System.err.println("\nOne condition: size = " + instances.sumOfWeights()); 
          JRip.NumericAntd numericAntd = null;
          if (attribute.isNumeric()) {
            numericAntd = new JRip.NumericAntd(this.this$0, attribute);
          } else {
            nominalAntd1 = new JRip.NominalAntd(this.this$0, attribute);
          } 
          if (!arrayOfBoolean[attribute.index()]) {
            Instances instances2 = computeInfoGain(instances, d3, nominalAntd1);
            if (instances2 != null) {
              double d4 = nominalAntd1.getMaxInfoGain();
              if (this.this$0.m_Debug)
                System.err.println("Test of '" + nominalAntd1.toString() + "': infoGain = " + d4 + " | Accuracy = " + nominalAntd1.getAccuRate() + "=" + nominalAntd1.getAccu() + "/" + nominalAntd1.getCover() + " def. accuracy: " + d3); 
              if (d4 > d) {
                nominalAntd = nominalAntd1;
                instances1 = instances2;
                d = d4;
              } 
            } 
          } 
        } 
        if (nominalAntd == null || Utils.sm(nominalAntd.getAccu(), this.this$0.m_MinNo))
          break; 
        if (!nominalAntd.getAttr().isNumeric()) {
          arrayOfBoolean[nominalAntd.getAttr().index()] = true;
          i--;
        } 
        this.m_Antds.addElement(nominalAntd);
        instances = instances1;
        d3 = nominalAntd.getAccuRate();
      } 
    }
    
    private Instances computeInfoGain(Instances param1Instances, double param1Double, JRip.Antd param1Antd) {
      Instances instances = param1Instances;
      Instances[] arrayOfInstances = param1Antd.splitData(instances, param1Double, this.m_Consequent);
      return (arrayOfInstances != null) ? arrayOfInstances[(int)param1Antd.getAttrValue()] : null;
    }
    
    public void prune(Instances param1Instances, boolean param1Boolean) {
      // Byte code:
      //   0: aload_1
      //   1: astore_3
      //   2: aload_3
      //   3: invokevirtual sumOfWeights : ()D
      //   6: dstore #4
      //   8: dload #4
      //   10: dconst_0
      //   11: invokestatic gr : (DD)Z
      //   14: ifne -> 18
      //   17: return
      //   18: aload_0
      //   19: aload_3
      //   20: invokespecial computeDefAccu : (Lweka/core/Instances;)D
      //   23: dstore #6
      //   25: aload_0
      //   26: getfield this$0 : Lweka/classifiers/rules/JRip;
      //   29: invokestatic access$000 : (Lweka/classifiers/rules/JRip;)Z
      //   32: ifeq -> 76
      //   35: getstatic java/lang/System.err : Ljava/io/PrintStream;
      //   38: new java/lang/StringBuffer
      //   41: dup
      //   42: invokespecial <init> : ()V
      //   45: ldc 'Pruning with '
      //   47: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuffer;
      //   50: dload #6
      //   52: invokevirtual append : (D)Ljava/lang/StringBuffer;
      //   55: ldc ' positive data out of '
      //   57: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuffer;
      //   60: dload #4
      //   62: invokevirtual append : (D)Ljava/lang/StringBuffer;
      //   65: ldc ' instances'
      //   67: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuffer;
      //   70: invokevirtual toString : ()Ljava/lang/String;
      //   73: invokevirtual println : (Ljava/lang/String;)V
      //   76: aload_0
      //   77: getfield m_Antds : Lweka/core/FastVector;
      //   80: invokevirtual size : ()I
      //   83: istore #8
      //   85: iload #8
      //   87: ifne -> 91
      //   90: return
      //   91: iload #8
      //   93: newarray double
      //   95: astore #9
      //   97: iload #8
      //   99: newarray double
      //   101: astore #10
      //   103: iload #8
      //   105: newarray double
      //   107: astore #11
      //   109: iconst_0
      //   110: istore #12
      //   112: iload #12
      //   114: iload #8
      //   116: if_icmpge -> 143
      //   119: aload #9
      //   121: iload #12
      //   123: aload #10
      //   125: iload #12
      //   127: aload #11
      //   129: iload #12
      //   131: dconst_0
      //   132: dup2_x2
      //   133: dastore
      //   134: dup2_x2
      //   135: dastore
      //   136: dastore
      //   137: iinc #12, 1
      //   140: goto -> 112
      //   143: dconst_0
      //   144: dstore #12
      //   146: iconst_0
      //   147: istore #14
      //   149: iload #14
      //   151: iload #8
      //   153: if_icmpge -> 364
      //   156: aload_0
      //   157: getfield m_Antds : Lweka/core/FastVector;
      //   160: iload #14
      //   162: invokevirtual elementAt : (I)Ljava/lang/Object;
      //   165: checkcast weka/classifiers/rules/JRip$Antd
      //   168: astore #15
      //   170: aload #15
      //   172: invokevirtual getAttr : ()Lweka/core/Attribute;
      //   175: astore #16
      //   177: aload_3
      //   178: astore #17
      //   180: new weka/core/Instances
      //   183: dup
      //   184: aload #17
      //   186: iconst_0
      //   187: invokespecial <init> : (Lweka/core/Instances;I)V
      //   190: astore_3
      //   191: iconst_0
      //   192: istore #18
      //   194: iload #18
      //   196: aload #17
      //   198: invokevirtual numInstances : ()I
      //   201: if_icmpge -> 306
      //   204: aload #17
      //   206: iload #18
      //   208: invokevirtual instance : (I)Lweka/core/Instance;
      //   211: astore #19
      //   213: aload #15
      //   215: aload #19
      //   217: invokevirtual covers : (Lweka/core/Instance;)Z
      //   220: ifeq -> 272
      //   223: aload #10
      //   225: iload #14
      //   227: dup2
      //   228: daload
      //   229: aload #19
      //   231: invokevirtual weight : ()D
      //   234: dadd
      //   235: dastore
      //   236: aload_3
      //   237: aload #19
      //   239: invokevirtual add : (Lweka/core/Instance;)V
      //   242: aload #19
      //   244: invokevirtual classValue : ()D
      //   247: d2i
      //   248: aload_0
      //   249: getfield m_Consequent : D
      //   252: d2i
      //   253: if_icmpne -> 300
      //   256: aload #11
      //   258: iload #14
      //   260: dup2
      //   261: daload
      //   262: aload #19
      //   264: invokevirtual weight : ()D
      //   267: dadd
      //   268: dastore
      //   269: goto -> 300
      //   272: iload_2
      //   273: ifeq -> 300
      //   276: aload #19
      //   278: invokevirtual classValue : ()D
      //   281: d2i
      //   282: aload_0
      //   283: getfield m_Consequent : D
      //   286: d2i
      //   287: if_icmpeq -> 300
      //   290: dload #12
      //   292: aload #19
      //   294: invokevirtual weight : ()D
      //   297: dadd
      //   298: dstore #12
      //   300: iinc #18, 1
      //   303: goto -> 194
      //   306: iload_2
      //   307: ifeq -> 336
      //   310: aload #11
      //   312: iload #14
      //   314: dup2
      //   315: daload
      //   316: dload #12
      //   318: dadd
      //   319: dastore
      //   320: aload #9
      //   322: iload #14
      //   324: aload #11
      //   326: iload #14
      //   328: daload
      //   329: dload #4
      //   331: ddiv
      //   332: dastore
      //   333: goto -> 358
      //   336: aload #9
      //   338: iload #14
      //   340: aload #11
      //   342: iload #14
      //   344: daload
      //   345: dconst_1
      //   346: dadd
      //   347: aload #10
      //   349: iload #14
      //   351: daload
      //   352: ldc2_w 2.0
      //   355: dadd
      //   356: ddiv
      //   357: dastore
      //   358: iinc #14, 1
      //   361: goto -> 149
      //   364: dload #6
      //   366: dconst_1
      //   367: dadd
      //   368: dload #4
      //   370: ldc2_w 2.0
      //   373: dadd
      //   374: ddiv
      //   375: dstore #14
      //   377: iconst_m1
      //   378: istore #16
      //   380: iconst_0
      //   381: istore #17
      //   383: iload #17
      //   385: aload #11
      //   387: arraylength
      //   388: if_icmpge -> 519
      //   391: aload_0
      //   392: getfield this$0 : Lweka/classifiers/rules/JRip;
      //   395: invokestatic access$000 : (Lweka/classifiers/rules/JRip;)Z
      //   398: ifeq -> 491
      //   401: iload_2
      //   402: ifeq -> 410
      //   405: dload #4
      //   407: goto -> 415
      //   410: aload #10
      //   412: iload #17
      //   414: daload
      //   415: dstore #18
      //   417: getstatic java/lang/System.err : Ljava/io/PrintStream;
      //   420: new java/lang/StringBuffer
      //   423: dup
      //   424: invokespecial <init> : ()V
      //   427: iload #17
      //   429: invokevirtual append : (I)Ljava/lang/StringBuffer;
      //   432: ldc '(useAccuray? '
      //   434: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuffer;
      //   437: iload_2
      //   438: ifne -> 445
      //   441: iconst_1
      //   442: goto -> 446
      //   445: iconst_0
      //   446: invokevirtual append : (Z)Ljava/lang/StringBuffer;
      //   449: ldc '): '
      //   451: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuffer;
      //   454: aload #9
      //   456: iload #17
      //   458: daload
      //   459: invokevirtual append : (D)Ljava/lang/StringBuffer;
      //   462: ldc '='
      //   464: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuffer;
      //   467: aload #11
      //   469: iload #17
      //   471: daload
      //   472: invokevirtual append : (D)Ljava/lang/StringBuffer;
      //   475: ldc '/'
      //   477: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuffer;
      //   480: dload #18
      //   482: invokevirtual append : (D)Ljava/lang/StringBuffer;
      //   485: invokevirtual toString : ()Ljava/lang/String;
      //   488: invokevirtual println : (Ljava/lang/String;)V
      //   491: aload #9
      //   493: iload #17
      //   495: daload
      //   496: dload #14
      //   498: dcmpl
      //   499: ifle -> 513
      //   502: aload #9
      //   504: iload #17
      //   506: daload
      //   507: dstore #14
      //   509: iload #17
      //   511: istore #16
      //   513: iinc #17, 1
      //   516: goto -> 383
      //   519: iload #8
      //   521: iconst_1
      //   522: isub
      //   523: istore #17
      //   525: iload #17
      //   527: iload #16
      //   529: if_icmple -> 547
      //   532: aload_0
      //   533: getfield m_Antds : Lweka/core/FastVector;
      //   536: iload #17
      //   538: invokevirtual removeElementAt : (I)V
      //   541: iinc #17, -1
      //   544: goto -> 525
      //   547: return
    }
    
    public String toString(Attribute param1Attribute) {
      StringBuffer stringBuffer = new StringBuffer();
      if (this.m_Antds.size() > 0) {
        for (byte b = 0; b < this.m_Antds.size() - 1; b++)
          stringBuffer.append("(" + ((JRip.Antd)this.m_Antds.elementAt(b)).toString() + ") and "); 
        stringBuffer.append("(" + ((JRip.Antd)this.m_Antds.lastElement()).toString() + ")");
      } 
      stringBuffer.append(" => " + param1Attribute.name() + "=" + param1Attribute.value((int)this.m_Consequent));
      return stringBuffer.toString();
    }
  }
  
  private class NominalAntd extends Antd {
    private double[] accurate;
    
    private double[] coverage;
    
    private final JRip this$0;
    
    public NominalAntd(JRip this$0, Attribute param1Attribute) {
      super(this$0, param1Attribute);
      this.this$0 = this$0;
      int i = this.att.numValues();
      this.accurate = new double[i];
      this.coverage = new double[i];
    }
    
    public Object copy() {
      NominalAntd nominalAntd = new NominalAntd(this.this$0, getAttr());
      nominalAntd.value = this.value;
      return nominalAntd;
    }
    
    public Instances[] splitData(Instances param1Instances, double param1Double1, double param1Double2) {
      int i = this.att.numValues();
      Instances[] arrayOfInstances = new Instances[i];
      byte b;
      for (b = 0; b < i; b++) {
        arrayOfInstances[b] = new Instances(param1Instances, param1Instances.numInstances());
        this.accurate[b] = 0.0D;
        this.coverage[b] = 0.0D;
      } 
      for (b = 0; b < param1Instances.numInstances(); b++) {
        Instance instance = param1Instances.instance(b);
        if (!instance.isMissing(this.att)) {
          int j = (int)instance.value(this.att);
          arrayOfInstances[j].add(instance);
          this.coverage[j] = this.coverage[j] + instance.weight();
          if ((int)instance.classValue() == (int)param1Double2)
            this.accurate[j] = this.accurate[j] + instance.weight(); 
        } 
      } 
      for (b = 0; b < i; b++) {
        double d1 = this.coverage[b] + 1.0D;
        double d2 = this.accurate[b] + 1.0D;
        double d3 = this.accurate[b] * (Utils.log2(d2 / d1) - Utils.log2(param1Double1));
        if (d3 > this.maxInfoGain) {
          this.maxInfoGain = d3;
          this.cover = this.coverage[b];
          this.accu = this.accurate[b];
          this.accuRate = d2 / d1;
          this.value = b;
        } 
      } 
      return arrayOfInstances;
    }
    
    public boolean covers(Instance param1Instance) {
      boolean bool = false;
      if (!param1Instance.isMissing(this.att) && (int)param1Instance.value(this.att) == (int)this.value)
        bool = true; 
      return bool;
    }
    
    public String toString() {
      return this.att.name() + " = " + this.att.value((int)this.value);
    }
  }
  
  private class NumericAntd extends Antd {
    private double splitPoint;
    
    private final JRip this$0;
    
    public NumericAntd(JRip this$0, Attribute param1Attribute) {
      super(this$0, param1Attribute);
      this.this$0 = this$0;
      this.splitPoint = Double.NaN;
    }
    
    public double getSplitPoint() {
      return this.splitPoint;
    }
    
    public Object copy() {
      NumericAntd numericAntd = new NumericAntd(this.this$0, getAttr());
      numericAntd.value = this.value;
      numericAntd.splitPoint = this.splitPoint;
      return numericAntd;
    }
    
    public Instances[] splitData(Instances param1Instances, double param1Double1, double param1Double2) {
      Instances instances = param1Instances;
      int i = instances.numInstances();
      byte b1 = 1;
      byte b2 = 0;
      byte b3 = b1;
      this.maxInfoGain = 0.0D;
      this.value = 0.0D;
      double d1 = 0.0D;
      double d2 = 0.0D;
      double d3 = 0.0D;
      double d4 = 0.0D;
      instances.sort(this.att);
      byte b4;
      for (b4 = 0; b4 < instances.numInstances(); b4++) {
        Instance instance = instances.instance(b4);
        if (instance.isMissing(this.att)) {
          i = b4;
          break;
        } 
        d2 += instance.weight();
        if (Utils.eq(instance.classValue(), param1Double2))
          d4 += instance.weight(); 
      } 
      if (i == 0)
        return null; 
      this.splitPoint = instances.instance(i - 1).value(this.att);
      while (b1 <= i) {
        if (b1 == i || instances.instance(b1).value(this.att) > instances.instance(b2).value(this.att)) {
          boolean bool;
          double d9;
          double d10;
          double d11;
          double d12;
          for (b4 = b2; b4 < b1; b4++) {
            Instance instance = instances.instance(b4);
            d1 += instance.weight();
            if (Utils.eq(instances.instance(b4).classValue(), param1Double2))
              d3 += instance.weight(); 
          } 
          double d5 = (d3 + 1.0D) / (d1 + 1.0D);
          double d6 = (d4 + 1.0D) / (d2 + 1.0D);
          double d7 = d3 * (Utils.log2(d5) - Utils.log2(param1Double1));
          double d8 = d4 * (Utils.log2(d6) - Utils.log2(param1Double1));
          if (d7 > d8) {
            bool = true;
            d10 = d7;
            d9 = d5;
            d12 = d3;
            d11 = d1;
          } else {
            bool = false;
            d10 = d8;
            d9 = d6;
            d12 = d4;
            d11 = d2;
          } 
          if (d10 > this.maxInfoGain) {
            this.splitPoint = instances.instance(b2).value(this.att);
            this.value = bool ? 0.0D : 1.0D;
            this.accuRate = d9;
            this.accu = d12;
            this.cover = d11;
            this.maxInfoGain = d10;
            b3 = bool ? b1 : b2;
          } 
          for (byte b = b2; b < b1; b++) {
            Instance instance = instances.instance(b);
            d2 -= instance.weight();
            if (Utils.eq(instances.instance(b).classValue(), param1Double2))
              d4 -= instance.weight(); 
          } 
          b2 = b1;
        } 
        b1++;
      } 
      Instances[] arrayOfInstances = new Instances[2];
      arrayOfInstances[0] = new Instances(instances, 0, b3);
      arrayOfInstances[1] = new Instances(instances, b3, i - b3);
      return arrayOfInstances;
    }
    
    public boolean covers(Instance param1Instance) {
      boolean bool = true;
      if (!param1Instance.isMissing(this.att)) {
        if ((int)this.value == 0) {
          if (param1Instance.value(this.att) > this.splitPoint)
            bool = false; 
        } else if (param1Instance.value(this.att) < this.splitPoint) {
          bool = false;
        } 
      } else {
        bool = false;
      } 
      return bool;
    }
    
    public String toString() {
      String str = ((int)this.value == 0) ? " <= " : " >= ";
      return this.att.name() + str + Utils.doubleToString(this.splitPoint, 6);
    }
  }
  
  private abstract class Antd implements WeightedInstancesHandler, Copyable, Serializable {
    protected Attribute att;
    
    protected double value;
    
    protected double maxInfoGain;
    
    protected double accuRate;
    
    protected double cover;
    
    protected double accu;
    
    private final JRip this$0;
    
    public Antd(JRip this$0, Attribute param1Attribute) {
      this.this$0 = this$0;
      this.att = param1Attribute;
      this.value = Double.NaN;
      this.maxInfoGain = 0.0D;
      this.accuRate = Double.NaN;
      this.cover = Double.NaN;
      this.accu = Double.NaN;
    }
    
    public abstract Instances[] splitData(Instances param1Instances, double param1Double1, double param1Double2);
    
    public abstract boolean covers(Instance param1Instance);
    
    public abstract String toString();
    
    public abstract Object copy();
    
    public Attribute getAttr() {
      return this.att;
    }
    
    public double getAttrValue() {
      return this.value;
    }
    
    public double getMaxInfoGain() {
      return this.maxInfoGain;
    }
    
    public double getAccuRate() {
      return this.accuRate;
    }
    
    public double getAccu() {
      return this.accu;
    }
    
    public double getCover() {
      return this.cover;
    }
  }
}


/* Location:              C:\Users\1231\Desktop\dataprocessing\activelearning\Clus-AL\Clus-AL\ClusAL\!\jars\weka.jar!\weka\classifiers\rules\JRip.class
 * Java compiler version: 2 (46.0)
 * JD-Core Version:       1.1.3
 */