train.select.data2 <- selectdatatodivide[[1]]
valid.select.data2 <- selectdatatodivide[[2]]
test.select.data2 <- selectdatatodivide[[3]]
####python输出的new.csv####
setwd("C:\\Users\\1231\\Desktop\\dataprocessing")
new <- read.csv(paste("new",datasetindex,".csv",sep = ""),header = FALSE)
measure.resultnew=MHevaluate(new,test.select.table2)
setwd("C:\\Users\\1231\\Desktop\\dataprocessing\\data\\204result")
fname <- paste("lstm",datasetindex,".txt",sep = "")
write.table(measure.resultnew,fname,sep = ",",quote = FALSE,row.names = FALSE)
####lstm的ch2loss####
aa <- datasetindex
fname <- paste("new",aa,"prob.csv",sep = "")
setwd("C:/Users/1231/Desktop/dataprocessing")
prob.is.one=read.csv(fname,header = FALSE)
w1=1
w3=1
w2=2
w4=2
c.matrix=matrix(0,nodes.total.num,1)
c.matrix[1,1]=1
go.for.level.index2 <- vector("list",length = length(go.for.level2))
for (j in 1:length(go.for.level.index2)) {
go.for.level.index2[[j]] <- which(except.root.labels2 %in% go.for.level2[[j]])
}
#计算Ci,该值仅与节点有关，对每个样本均相同
for(k in 1:length(go.for.level.index2))
{
for (i in 1:length(go.for.level.index2[[k]])) {
if( k == 1)
{
sibling.num2=each.level.nodes.num2[[1]]
c.matrix[((go.for.level.index2[[1]][i])+1),1]=1/sibling.num2
}
else
{
parentnode.num2=length(nodes.to.parents2[[except.root.labels2[go.for.level.index2[[k]][i]]]])
current.c=0
for(j in 1:parentnode.num2)
{
parentnode.index2=nodes.to.parents2[[except.root.labels2[go.for.level.index2[[k]][i]]]][j]
sibling.num2=length(nodes.to.children2[[except.root.labels2[parentnode.index2]]])
#current.c=current.c+c.matrix[parentnode.index2,1]/sibling.num2
current.c=current.c+c.matrix[(parentnode.index2+1),1]/sibling.num2
}
# c.matrix[((go.for.level.index2[[k]][i])+1),1] = current.c
c.matrix[((go.for.level.index2[[k]][i])+1),1]=current.c/parentnode.num2
}
}
}
###变换节点函数只需要这一块注释/拿走注释
c.matrix=matrix(1,nodes.total.num,1)
#计算pi
p.matrix=cbind(matrix(1,nrow(prob.is.one),1),prob.is.one)
sigma.one=matrix(0,nrow(prob.is.one),nodes.total.num)
sigma.two=matrix(0,nrow(prob.is.one),nodes.total.num)
#求解sigma(1)
for(k in 1:nrow(prob.is.one))
{
for(i in 1:nodes.total.num)
{
cur.node=select.nodes2[i]
is.leafnode=cur.node %in% go.leaf.nodes2
if(is.leafnode==TRUE)
{
sigma.one[k,i]=0
} else
{
children.index=nodes.to.children2.ch[[select.nodes2[i]]]
children.num=length(children.index)
inter.value=0
for(j in 1:children.num)
{
inter.value=inter.value+ c.matrix[(children.index[j]+1),1]*p.matrix[k,(children.index[j]+1)]
}
sigma.one[k,i]=(w2-w1)*inter.value
}
}
}
#求解sigma(2)
for(k in 1:nrow(prob.is.one))
{
for(i in 1:(nodes.total.num))
{
cur.node.index=i-1
if(nodes.to.index2.ch[i]==0)
{
sigma.two[k,i]=0
}else
{
parents.index=nodes.to.parents2.ch[[i]]
parents.num=length(parents.index)
inter.value=1
for(j in 1:parents.num)
{
inter.value=inter.value*p.matrix[k,(parents.index[j]+1)]
}
value.one=w1*c.matrix[i,1]*p.matrix[k,i]*parents.num
value.two=w3*c.matrix[i,1]*parents.num*(inter.value-p.matrix[k,i])
value.three=w4*c.matrix[i,1]*parents.num*(1-inter.value)
sigma.two[k,i]=value.one-value.two-value.three
}
}
}
sigma=sigma.one+sigma.two
####lstm的DAGlabel####
#DAGlabel的实现，在rebuilddataprocess.R，chloss2.R之后运行
#主要内容有寻找sigma最大节点，寻找其待结合的父节点，节点合成和修改层级关系几部分。
# work.path="F://R//CODES"
# data.path="F://R//DATA"
# setwd(work.path)
# source("headfile.R")
y=matrix(data = 0, nrow = nrow(sigma), ncol = (ncol(sigma)+300)) #y矩阵 列有扩充，用于存放合成的节点
y[,ncol(sigma)]=1   #根节点为1
#生成withroot.nodes.to.children2,withroot.nodes.to.parents2
with.root.labels2 <- c(except.root.labels2,"GO0008150")
withroot.nodes.to.children2 <- vector("list",length = length(with.root.labels2))
names(withroot.nodes.to.children2) <- with.root.labels2
firstlevelnodes2 <- which(except.root.labels2 %in% go.for.level2[[1]])
withroot.nodes.to.children2 <- nodes.to.children2
withroot.nodes.to.children2[[with.root.labels2[length(with.root.labels2)]]] <- which(except.root.labels2 %in% go.for.level2[[1]])
withroot.nodes.to.parents2 <- vector("list",length = length(with.root.labels2))
names(withroot.nodes.to.parents2) <- with.root.labels2
withroot.nodes.to.parents2 <- nodes.to.parents2
for (i in 1:length(firstlevelnodes2)) {
withroot.nodes.to.parents2[[except.root.labels2[firstlevelnodes2[i]]]] <- length(with.root.labels2)
}
withroot.nodes.to.parents2[[with.root.labels2[length(with.root.labels2)]]] <- NA
for(k in 1:nrow(sigma)) #K为样本数
{
cat(k,"\n")
#每次循环时，初始化
nodes_to_children = withroot.nodes.to.children2  #子节点list
nodes_to_parents= withroot.nodes.to.parents2     #父节点list
#每一个样本的sigma矩阵（无根节点）,寻找最大值时，会有改动
si=matrix(data = 0, nrow =ncol(sigma)-1, ncol = 2)
si[,1]=1:(ncol(sigma)-1)
si[,2]=sigma[k,2:ncol(sigma)]   #提取sigma矩阵的第k行
#每一个样本的sigma矩阵（有根节点，在最后），无改动
total_si=matrix(data = 0, nrow =ncol(sigma), ncol = 2)
total_si[,1]=1:ncol(sigma)
total_si[ncol(sigma),1]=ncol(sigma)
total_si[ncol(sigma),2]=50      #假设给根节点一个较大的sigma值，值无影响，较大即可
total_si[(1:ncol(sigma)-1),]=si #提取sigma矩阵的第k行
bignodes=matrix(data = 0, nrow =1, ncol = 2) #合成节点矩阵
relation=matrix(data = 1, nrow =1, ncol = 2) #存放合成前的节点与合成后的节点
rei=matrix(data = 1, nrow =2, ncol = 2) #存放合成前的节点与合成后的节点
find.max=which(si[,2]==max(si[,2]))  #寻找sigma最大值的下角标
find.max=sort(find.max,decreasing = F) #可能有多个值最大且相等，优先取下角标最小的
find.max=find.max[1]  #sigma最大值的下角标
p=1 #中间变量的初始化 用于合成节点的标号
list_parentnodes=list() #用于存放待结合的父节点的下角标
while((si[find.max,2]>=0)&&(sum(y[k,1:ncol(sigma)])<ncol(sigma))&&length(is.na(si))!=0) #sigma最大值小于0或者所有数据都已标记后，退出
{
#print(si[find.max,1])
num_parentnodes=length(nodes_to_parents[[si[find.max,1]]]) #sigma最大的节点的父节点个数
labeled_count=0    #已标记父节点个数
for(i in 1:num_parentnodes)
{
if(y[k,nodes_to_parents[[si[find.max,1]]][i]]==1)
{
labeled_count=labeled_count+1
}
}
if(labeled_count== num_parentnodes)  #所有父节点已经标记
{
y[k,si[find.max,1]]=1   #该节点标记为1
si=si[-find.max,]       #移出si矩阵
}else   #找到sigma小于0的父节点，一个或一个以上
{
#计算父节点中sigma值小于0的个数，当父节点sigma值小于0个数大于等于1的情况，揪出全部sigma小于0的父节点进行操作
num_combinenodes=0 #待合成父节点的个数
list_parentnodes=list() #存放父节点的下角标
for(m in 1:num_parentnodes)
{
row_parentnode=which(total_si[,1]==nodes_to_parents[[si[find.max,1]]][m])
if(total_si[row_parentnode,2]<0)
{
num_combinenodes=num_combinenodes+1
list_parentnodes=append(list_parentnodes,row_parentnode) #pa里存放的是待合成的父节点下角标，
}
}
#当父节点sigma值全部大于0的情况，找到sigma值最小的父节点进行操作
if(num_combinenodes<=1) #找最小sigma，要返回一个1
{
list_parentnodes=list() #存放父节点的下角标
min_panodes_sigma=10  #数值是多少无意义，只要比真实sigma值大就可以
#找sigma值最小的父节点
for(i in 1:num_parentnodes)
{
row_parentnode=which(total_si[,1]==nodes_to_parents[[si[find.max,1]]][i]) #父节点的下角标 nodes_to_parents已经更改
sigama_of_parent=total_si[row_parentnode,2]  #父节点的sigma值
if(min_panodes_sigma>=sigama_of_parent)
{
min_panodes_sigma = sigama_of_parent   #父节点的sigma的最小值
node_parent=total_si[row_parentnode,1]    #sigma取最小值时的父节点
}
}
row_parentnode=which(total_si[,1]==node_parent)    #父节点下角标
list_parentnodes=append(list_parentnodes,row_parentnode)   #pa里存放的是待合成的父节点下角标
num_combinenodes=1
}
#合成节点
rei[1,1]=si[find.max,1]
value_bignodes=si[find.max,2] #子节点的sigma值
m=1 #循环变量
while(m<=num_combinenodes)
{
#构建合成节点
value_bignodes=(value_bignodes*m+total_si[list_parentnodes[[m]],2])/(m+1)
bignodes[1,1]=ncol(sigma)+p   #合成节点
bignodes[1,2]=value_bignodes
si=rbind(si,bignodes)   #合成节点拼接到si后面
total_si=rbind( total_si,bignodes)
# 小节点与合成节点对应关系
rei[1,2]=ncol(sigma)+p
rei[2,1]=total_si[list_parentnodes[[m]],1]
rei[2,2]=ncol(sigma)+p
relation=rbind(relation,rei) #合成节点矩阵
childnode=rei[1,1]
parentnode=total_si[list_parentnodes[[m]],1]
#correct hf 合成节点后，修改父子节点关系
#合成节点的父节点，就是上述父节点的父节点加上上述子节点的父节点（去掉上述父节点）
#nodes_to_parents[[parentnode]]+nodes_to_parents[[childnode]]-parentnode-重复的节点
list_nodes_to_parents=list()
#被吞并的父节点的父节点
list_nodes_to_parents[[1]]=nodes_to_parents[[parentnode]]
nodes_to_parents[[childnode]]=setdiff( nodes_to_parents[[childnode]],parentnode)
if(length( nodes_to_parents[[childnode]])!=0)
{
#加入吞并者——子节点的父节点,若是子节点的某一父节点l没在父节点的父节点里，就加进来
for(l in 1:length( nodes_to_parents[[childnode]]))
{
if(!is.element(nodes_to_parents[[childnode]][l],list_nodes_to_parents[[1]]))
{
list_nodes_to_parents[[1]][length(list_nodes_to_parents[[1]])+1]=nodes_to_parents[[childnode]][l]
}
}
}
nodes_to_parents=c(nodes_to_parents,list_nodes_to_parents)
#合成节点的子节点，就是上述父节点的子节点（去掉上述子节点）加上上述子节点的子节点
nodes_to_children[[parentnode]]=setdiff(nodes_to_children[[parentnode]],childnode)
list_nodes_to_children=list()
if( (length(nodes_to_children[[parentnode]])==0)&&is.na(nodes_to_children[[childnode]][1]))
{
list_nodes_to_children[[1]]=nodes_to_children[[childnode]]
nodes_to_children=c(nodes_to_children,list_nodes_to_children)
}
if( (length(nodes_to_children[[parentnode]])==0)&& !(is.na(nodes_to_children[[childnode]][1])))
{
list_nodes_to_children[[1]]=nodes_to_children[[childnode]]
nodes_to_children=c(nodes_to_children,list_nodes_to_children)
}
if( (length(nodes_to_children[[parentnode]])!=0)&& (is.na(nodes_to_children[[childnode]][1])))
{
list_nodes_to_children[[1]]=nodes_to_children[[parentnode]]
nodes_to_children=c(nodes_to_children,list_nodes_to_children)
}
if( (length(nodes_to_children[[parentnode]])!=0)&& !(is.na(nodes_to_children[[childnode]][1])))
{
list_nodes_to_children[[1]]=nodes_to_children[[childnode]]
for(l in 1:length( nodes_to_children[[parentnode]]))
{
if(!is.element(nodes_to_children[[parentnode]][l],list_nodes_to_children[[1]]))
{
list_nodes_to_children[[1]][length(list_nodes_to_children[[1]])+1]=nodes_to_children[[parentnode]][l]
}
}
nodes_to_children=c(nodes_to_children,list_nodes_to_children)
}
# 修改上述子节点的子节点的父为合成节点
if(!is.na(nodes_to_children[[childnode]][1]))
{
for(j in 1:length(nodes_to_children[[childnode]]))
{
#如果被合并的父节点是被合并的子节点的子节点的父节点，删掉这个父节点
if(is.element(parentnode,nodes_to_parents[[nodes_to_children[[childnode]][j]]]))
{
nodes_to_parents[[nodes_to_children[[childnode]][j]]]=setdiff(nodes_to_parents[[nodes_to_children[[childnode]][j]]],parentnode)
}
#如果被合并的子节点是被合并子节点的子节点的父节点，把它替换成最新节点
aa=nodes_to_parents[[nodes_to_children[[childnode]][j]]]
if(childnode %in% aa)
{
aa[which(aa==childnode)]=ncol(sigma)+p
nodes_to_parents[[nodes_to_children[[childnode]][j]]]=aa
}
}
}
# 修改上述父节点的子节点
if(length(nodes_to_children[[parentnode]])!=0)
{
for(j in 1:length(nodes_to_children[[parentnode]]))
{
aa=nodes_to_parents[[nodes_to_children[[parentnode]][j]]]
if(parentnode %in% aa)
{
aa[which(aa==parentnode)]=ncol(sigma)+p
nodes_to_parents[[nodes_to_children[[parentnode]][j]]]=aa
}
}
}
# 修改上述父节点的父节点
if(length(nodes_to_parents[[parentnode]])>0)
{
for(j in 1:length(nodes_to_parents[[parentnode]]))
{
if(length(nodes_to_children[[nodes_to_parents[[parentnode]][j]]])!=0)
{
nodes_to_children[[nodes_to_parents[[parentnode]][j]]]=setdiff(nodes_to_children[[nodes_to_parents[[parentnode]][j]]],childnode)
aa=nodes_to_children[[nodes_to_parents[[parentnode]][j]]]
if(parentnode %in% aa)
{
aa[which(aa==parentnode)]=ncol(sigma)+p
nodes_to_children[[nodes_to_parents[[parentnode]][j]]]=aa
}
}
}
}
# 修改上述子节点的父节点的子节点
if(length(nodes_to_parents[[childnode]])!=0)
{
for(j in 1:length(nodes_to_parents[[childnode]]))
{
aa=nodes_to_children[[nodes_to_parents[[childnode]][j]]]
if(childnode %in% aa)
{
aa[which(aa==childnode)]=ncol(sigma)+p
nodes_to_children[[nodes_to_parents[[childnode]][j]]]=aa
}
}
}
#考虑变成环形的特殊情况
if(length( nodes_to_parents[[childnode]])!=0 && length(nodes_to_children[[parentnode]])!=0)
{
for(r in 1:length(nodes_to_children[[parentnode]]))
{
for(q in 1:length(nodes_to_parents[[childnode]]))
{
if(nodes_to_children[[parentnode]][r]==nodes_to_parents[[childnode]][q])
{
cyclenode=nodes_to_parents[[childnode]][q]
#去环结构，合成节点作子节点
nodes_to_children[[ncol(sigma)+p]]=setdiff( nodes_to_children[[ncol(sigma)+p]],cyclenode)
nodes_to_parents[[cyclenode]]=setdiff( nodes_to_parents[[cyclenode]],ncol(sigma)+p)
list_parentnodes=append(list_parentnodes,which(total_si[,1]==cyclenode))
num_combinenodes=num_combinenodes+1
}
}
}
}
rei[1,1]=ncol(sigma)+p
p=p+1
si=si[-which(si[,1]==childnode),] #在sigma矩阵里，去掉子节点
for(dd in 1:nrow(si))            #在sigma矩阵里，去掉父节点，父节点可能已被去除，加上判断
{
if(si[dd,1]==parentnode)
{
si=si[-which(si[,1]==parentnode),]
break
}
}
m=m+1
#合成一次对应m=1,随后m+1推动合成第二次，直到list袋子里面所有节点合成完毕
}
}
######k=128,171时，仅有一个si值小于0，最后一步si被掏空得从matrix降级为含有两个num的vector
# if ((nrow(si)) != 0)
# {
if (is.null(nrow(si)) == FALSE )
{
find.max=which(si[,2]==max(si[,2])) #再次寻找最大值
find.max=sort(find.max,decreasing = F) # #可能有多个值最大且相等，优先取下角标最小的
find.max=find.max[1]  #sigma最大值的下角标
}
else
{
si = matrix(si,nrow = 1,ncol = 2)
find.max = 1
}
}
# }
#针对每个k值 将合成节点矩阵的信息反馈回y矩阵
######k=71时，没有节点合成，relation只有一行
if (nrow(relation) > 1)
{
for(z in nrow(relation):2)
{
if(y[k,relation[z,2]]==1)
{
y[k,relation[z,1]]=1
}
}
}
#####被多次合成的节点后面放一个！号#####
if (TRUE %in% duplicated(relation[,1]) )
{
cat(paste(k,"!"),"\n")
}
}
y=y[,1:(ncol(sigma)-1)]
#冲突函数
violate.list.final=ViolateDetectlabel(go.for.level2,go.leaf.nodes2,nodes.to.index2,nodes.to.children2,y)
measure.result.fin=MHevaluate(y,test.select.table2)
setwd("C:/Users/1231/Desktop/dataprocessing/data/204result")
###根据数据集不同，这里也要改
file.name <- paste("DAGlabellstm",datasetindex,".txt",sep = "")
write.table(measure.result.fin,file = file.name,row.names = FALSE,col.names = FALSE,sep = ",")
####SVM,MLP,lstm的原始结果和DAGlabel结果对比####
####构造结果汇总文件####
frame1hm <- matrix(nrow = 5,ncol = 3)
frame1hu <- matrix(nrow = 5,ncol = 3)
frame2hm <- matrix(nrow = 5,ncol = 3)
frame2hu <- matrix(nrow = 5,ncol = 3)
row.names(frame1hm) <- paste("dataset",1:5,sep = "")
row.names(frame1hu) <- paste("dataset",1:5,sep = "")
row.names(frame2hm) <- paste("dataset",1:5,sep = "")
row.names(frame2hu) <- paste("dataset",1:5,sep = "")
colnames(frame1hm) <- c("SVM","MLP","LSTM")
colnames(frame1hu) <- c("SVM","MLP","LSTM")
colnames(frame2hm) <- c("SVM-DAG","MLP-DAG","LSTM-DAG")
colnames(frame2hu) <- c("SVM-DAG","MLP-DAG","LSTM-DAG")
####读数据####
setwd("C:\\Users\\1231\\Desktop\\dataprocessing\\data\\204result")
for (p in 1:5) {
SVMfile <- paste("TPR",p,".txt",sep = "")
SVMresult <- read.table(SVMfile,header = FALSE,sep = ",")
MLPfile <- paste("nn",p,".txt",sep = "")
MLPresult <- read.table(MLPfile,header = TRUE,sep = ",")
LSTMfile <- paste("lstm",p,".txt",sep = "")
LSTMresult <- read.table(LSTMfile,header = TRUE,sep = ",")
SVMlabelfile <- paste("DAGlabel",p,".txt",sep = "")
SVMlabelresult <- read.table(SVMlabelfile,header = FALSE,sep = ",")
MLPlabelfile <- paste("DAGlabelnn",p,".txt",sep = "")
MLPlabelresult <- read.table(MLPlabelfile,header = FALSE,sep = ",")
LSTMlabelfile <- paste("DAGlabellstm",p,".txt",sep = "")
LSTMlabelresult <- read.table(LSTMlabelfile,header = FALSE,sep = ",")
####原始结果####
frame1hm[p,1] <- SVMresult[1,3]
frame1hm[p,2] <- MLPresult[1,3]
frame1hm[p,3] <- LSTMresult[1,3]
frame1hu[p,1] <- SVMresult[1,6]
frame1hu[p,2] <- MLPresult[1,6]
frame1hu[p,3] <- LSTMresult[1,6]
####DAGlabel结果####
frame2hm[p,1] <- SVMlabelresult[1,3]
frame2hm[p,2] <- MLPlabelresult[1,3]
frame2hm[p,3] <- LSTMlabelresult[1,3]
frame2hu[p,1] <- SVMlabelresult[1,6]
frame2hu[p,2] <- MLPlabelresult[1,6]
frame2hu[p,3] <- LSTMlabelresult[1,6]
}
write.csv(frame1hm,"hmresult1.csv",quote = FALSE,row.names = TRUE)
write.csv(frame1hu,"huresult1.csv",quote = FALSE,row.names = TRUE)
write.csv(frame2hm,"hmresultDAG.csv",quote = FALSE,row.names = TRUE)
write.csv(frame2hu,"huresultDAG.csv",quote = FALSE,row.names = TRUE)
hmresult <- cbind(frame1hm,frame2hm)
write.csv(hmresult,"hmresult0.csv",quote = FALSE,row.names = TRUE)
huresult <- cbind(frame1hu,frame2hu)
write.csv(huresult,"huresult0.csv",quote = FALSE,row.names = TRUE)
####SVM,MLP,lstm的原始结果和DAGlabel结果对比####
####构造结果汇总文件####
frame1hm <- matrix(nrow = 5,ncol = 3)
frame1hu <- matrix(nrow = 5,ncol = 3)
frame2hm <- matrix(nrow = 5,ncol = 3)
frame2hu <- matrix(nrow = 5,ncol = 3)
row.names(frame1hm) <- paste("dataset",1:5,sep = "")
row.names(frame1hu) <- paste("dataset",1:5,sep = "")
row.names(frame2hm) <- paste("dataset",1:5,sep = "")
row.names(frame2hu) <- paste("dataset",1:5,sep = "")
colnames(frame1hm) <- c("SVM","MLP","LSTM")
colnames(frame1hu) <- c("SVM","MLP","LSTM")
colnames(frame2hm) <- c("SVM-DAG","MLP-DAG","LSTM-DAG")
colnames(frame2hu) <- c("SVM-DAG","MLP-DAG","LSTM-DAG")
####读数据####
setwd("C:\\Users\\1231\\Desktop\\dataprocessing\\data\\204result")
for (p in 1:5) {
SVMfile <- paste("TPR",p,".txt",sep = "")
SVMresult <- read.table(SVMfile,header = FALSE,sep = ",")
MLPfile <- paste("nn",p,".txt",sep = "")
MLPresult <- read.table(MLPfile,header = TRUE,sep = ",")
LSTMfile <- paste("lstm",p,".txt",sep = "")
LSTMresult <- read.table(LSTMfile,header = TRUE,sep = ",")
SVMlabelfile <- paste("DAGlabel",p,".txt",sep = "")
SVMlabelresult <- read.table(SVMlabelfile,header = FALSE,sep = ",")
MLPlabelfile <- paste("DAGlabelnn",p,".txt",sep = "")
MLPlabelresult <- read.table(MLPlabelfile,header = FALSE,sep = ",")
LSTMlabelfile <- paste("DAGlabellstm",p,".txt",sep = "")
LSTMlabelresult <- read.table(LSTMlabelfile,header = FALSE,sep = ",")
####原始结果####
frame1hm[p,1] <- SVMresult[1,3]
frame1hm[p,2] <- MLPresult[1,3]
frame1hm[p,3] <- LSTMresult[1,3]
frame1hu[p,1] <- SVMresult[1,6]
frame1hu[p,2] <- MLPresult[1,6]
frame1hu[p,3] <- LSTMresult[1,6]
####DAGlabel结果####
frame2hm[p,1] <- SVMlabelresult[1,3]
frame2hm[p,2] <- MLPlabelresult[1,3]
frame2hm[p,3] <- LSTMlabelresult[1,3]
frame2hu[p,1] <- SVMlabelresult[1,6]
frame2hu[p,2] <- MLPlabelresult[1,6]
frame2hu[p,3] <- LSTMlabelresult[1,6]
}
write.csv(frame1hm,"hmresult1.csv",quote = FALSE,row.names = TRUE)
write.csv(frame1hu,"huresult1.csv",quote = FALSE,row.names = TRUE)
write.csv(frame2hm,"hmresultDAG.csv",quote = FALSE,row.names = TRUE)
write.csv(frame2hu,"huresultDAG.csv",quote = FALSE,row.names = TRUE)
hmresult <- cbind(frame1hm,frame2hm)
write.csv(hmresult,"hmresult0.csv",quote = FALSE,row.names = TRUE)
huresult <- cbind(frame1hu,frame2hu)
write.csv(huresult,"huresult0.csv",quote = FALSE,row.names = TRUE)
